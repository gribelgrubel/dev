<!DOCTYPE html>
<html lang="de">

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>Rundgang Finkenau 2020</title>
        <meta name="description" content="Rundgang Finkenau – Sommer 2020">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="resources/style.css">
        <link rel="icon" type="image/x-icon" href="resources/favicon.ico">
        <style class="__css_exfil_protection_filtered_styles"></style>
        
        <link rel="stylesheet" href="resources/swiper.min.css">
        
        <script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
        
        <!-- Matomo -->
        <script type="text/javascript">
            if (location.hostname.includes("haw-hamburg.de") || location.hostname === "141.22.177.246") {
                var _paq = window._paq || [];
                /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
                _paq.push(['trackPageView']);
                _paq.push(['enableLinkTracking']);
                (function() {
                    var u = "https://matomo.design.haw-hamburg.de/";
                    _paq.push(['setTrackerUrl', u + 'matomo.php']);
                    _paq.push(['setSiteId', '10']);
                    var d = document,
                        g = d.createElement('script'),
                        s = d.getElementsByTagName('script')[0];
                    g.type = 'text/javascript';
                    g.async = true;
                    g.defer = true;
                    g.src = u + 'matomo.js';
                    s.parentNode.insertBefore(g, s);
                })();
            }
        </script>
        <!-- End Matomo Code -->
        
    </head>

    <body>
        <div id="fullpage">

            <div id="landingcanvas">
                <div class="footer-link" style="margin:0.25em;position:absolute;top:0;right:0;font-size:4em;">
                        <a target="_blank" href="https://design.haw-hamburg.de/home/das-department-design/">
                        <img class="footerlogo" src="resources/haw-logo.svg" alt="HAW Hamburg"></a>
                </div>
            </div>

            <div class="section content-block" id="eingangstext">
                <div class="slide">
                    <h3 class="green">The end(s) of the world?</h3>
                    <p class="textblock">Stehen wir am Ende der Welt? Oder an einem Ende? Welche Welt könnte hier enden? Oder ist nicht vielmehr so: Corona zeigt, wie alle Enden der Welt zusammenhängen? Zusammenhänge werden offensichtlich. Die Welt ist eine Kugel. Es geht immer weiter, nur anders.</p>
                </div>

                <div class="slide">
                    <h3  class="grey">Wer wir sind </h3>
                    <p class="textblock">Angehende Kommunikationsdesigner*innen, die mit Blick auf eine aktuell schwer planbare Zukunft nach der praktischen Rolle von Design fragen. Im Sommersemester 2020 wollten wir das Erscheinungsbild für den Rundgang Finkenau gestalten, der am Ende des Semesters auf dem Kunst- und Mediencampus Hamburg stattfinden sollte. Die Sommerausstellung zeigt jedes Jahr Studien- und Abschlussarbeiten aus den Departments Design, Medientechnik und Information.<br> Jedoch nicht in diesem Jahr. Corona hat alles auf den Kopf gestellt und zu ganz anderen Fragestellungen geführt. </p>
                </div>

                <div class="slide">
                    <h3  class="yellow">Stillstand oder Aufbruch?</h3>
                    <p class="textblock">Statt ein Erscheinungsbild zu kreieren, stellen wir eine kryptische Frage. Wir wollen wissen, wie wir reagieren. Auf ein Ende der Welt. Erstarren wir? Fühlen wir Angst? Oder wählen wir Taten und Aktionismus? Initiieren wir einen Neustart? Trauen wir uns, Visionen von Hoffnung zu kreieren? Für alle. Sicher ist: wir wollen weiter machen. Auch in der Krise sind wir kreativ.</p>
                </div>

                <div class="slide">
                    <h3  class="blue">Allein oder zusammen? </h3>
                    <p class="textblock">Wie entsteht kreatives Arbeiten? Gelingt es in Stille? Ohne Austausch mit anderen? Können Strukturen helfen, kreative Prozesse in Gang zu setzen? Oder kommt alles aus uns heraus? Irgendwann. Das Semester begann mit dem Lockdown. Am Anfang war alles eng. Allein am Schreibtisch, ohne Freund*innen, ohne Kommiliton*innen. Lehre über den Bildschirm. Arbeiten, hadern, forschen, wieder anfangen, noch mal von vorne. Gegen den Stillstand. Vieles funktioniert in der digitalen Welt. Aber nicht alles. Und nichts kann das direkte Gespräch ersetzen. </p>
                </div>

                <div class="slide">
                    <h3  class="orange">Wenn Corona das Internet verschluckt?</h3>
                    <p class="textblock">Wo wären wir ohne Zoom, ohne Teams, ohne E-Mails, ohne Online-Calls? Wenn wir digital nicht verbunden wären, was würden wir wählen? Würden wir mal wieder Briefe oder Postkarten schreiben? Ja, denn wir wollen miteinander im Gespräch bleiben. </p>
                </div>

                <div class="slide">
                    <h3  class="green">Die eine Antwort gibt es nicht.</h3>
                    <p class="textblock">Die Frage nach den Enden der Welt übersetzen wir in buntes typografisches Bild mit Lust auf Farbe. Die Buchstaben sind eng ins Format gedrängt, als hätten sie zu wenig Platz im Homeoffice. Die Pixelcursor spiegeln den momentanen Umgang mit digitalen Medien wider: Manchmal wirkt es so, als benutzen wir zum ersten Mal das Internet. Oder? </p>
                </div>
            </div>
            
            <div class="section content-block" style="margin:2em 0" id="armgart">
                <h1 class="green bordered">Rundgang Finkenau 2020</h1>
                <p class="textblock">Die diesjährige Sommerausstellung findet aufgrund der Pandemie leider nicht statt.</p>
            </div>
            
            <div class="section paddingless" id="fotocarousel">
                                
                <div class="galeriecatg marginchild">
                    <h2 class="blue"><span class="dropIcon">↓</span> Stadtrundgang</h2>
                    <div class="coming-soon" style="display:none;"><p>Coming soon!</p></div>
                    <!--
                    <div class="swiper-container">
                        <div class="swiper-wrapper">
                            <div class="swiper-slide"></div>
                            <div class="swiper-slide"><img src="img/litfass.png" class=foto></div>
                            <div class="swiper-slide"><img src="img/billboard.png" class=foto></div>
                            <div class="swiper-slide"><img src="img/litfass.png" class=foto></div>
                            <div class="swiper-slide"><img src="img/subway-ad.png" class=foto></div>
                        </div>
                        <div class="swiper-button-prev"></div>
                        <div class="swiper-button-next"></div>
                    </div>
                    -->
                </div>
                
                <div class="galeriecatg marginchild">
                    <h2 class="green"><span class="dropIcon">↓</span> Social Media</h2>
                    <div class="coming-soon" style="display:none;"><p>Coming soon!</p></div>
                </div>
                
                <div class="galeriecatg marginchild">
                    <h2 class="grey"><span class="dropIcon">↓</span> Rundgang 2019/20</h2>
                    <div class="coming-soon" style="display:none;"><p>Coming soon!</p></div>
                </div>
                                
            </div>
            
            <div class="section content-block" id="team">
                
                <h1 class="marginless green bordered">Team</h1>
                <div class="content_text">
                    <p>Das Erscheinungsbild des Rundgang Finkenau 2020 wurde von Studierenden des Studiengang Kommunikationsdesign an der Fakultät DMI der HAW Hamburg unter der Leitung von Paul Rutrecht und Hendrike Schmietendorf gestaltet: Frederik Engelbrecht, Georg Randel, Janna Thaden, Laura Dunse, Mert Ekinci, Rebecca Söhlke.</p>
                    <table id="teamtable">
                        <tr>
                            <th><h2 class="orange bordered">Studierende</h2></th>
                        </tr>
                        <tr>
                            <td>Georg Randel</td>
                            <td>georg.randel@yahoo.de</td>
                        </tr>
                        <tr>
                            <td>Janna Thaden</td>
                            <td>janna.thaden@gmx.net</td>
                        </tr>
                        <tr>
                            <td>Laura Dunse</td>
                            <td>laura.dunse@gmx.de</td>
                        </tr>
                        <tr>
                            <td>Mert Ekinci</td>
                            <td>mert.ekinci@haw-hamburg.de</td>
                        </tr>
                        <tr>
                            <td>Rebecca Söhlke</td>
                            <td>rebeccasoehlke@web.de</td>
                        </tr>
                        <tr>
                            <th><h2 class="lila bordered">Code</h2></th>
                        </tr>
                        <tr>
                            <td>Frederik Engelbrecht</td>
                            <td>fre.engelbrecht@gmail.com</td>
                        </tr>
                        <tr>
                            <th><h2 class="blue bordered">Betreuung</h2></th>
                        </tr>
                        <tr>
                            <td>Paul Rutrecht</td>
                            <td>mail@paulrutrecht.de</td>
                        </tr>
                        <tr>
                            <th><h2 class="grey bordered">Kommunikation</h2></th>
                        </tr>
                        <tr>
                            <td>Hendrike Schmietendorf</td>
                            <td>hendrike.schmietendorf@haw-hamburg.de</td>
                        </tr>
                    </table>
                </div>
                
            </div>
            
            <div class="section content-block spacer-top" id="armgart">
                <h1 class="green bordered">Ausblick</h1>
                <p class="textblock">Wir freuen uns darauf, euch auf dem Rundgang Armgartstraße Anfang 2021 wieder alle dort zu treffen. Sobald ein genauerer Termin feststeht, informieren wir euch hier und über die sozialen Medien!</p>
                <!-- <p class="textblock"><a href="">Erinner' mich dran, sobald es ein Datum gibt!</a></p>   -->
                <div id="backtotop"><a href="#">↑</a></div>
            </div>
            
            <div id="footer">
                    <div class="footer-link"><a href="impressum.html">Impressum & Datenschutz</a></div>
                    <div class="footer-link"><a href="https://www.instagram.com/haw_dmi/">Instagram</a></div>
                    <div class="footer-link"><a href="https://www.facebook.com/HAW.DMI">Facebook</a></div>
                <!--
                    <div class="footer-link">
                        <a class="smicon" target="_blank" href="https://design.haw-hamburg.de/home/das-department-design/">
                        <img class="footerlogo" src="resources/haw-logo.svg" alt="HAW Hamburg"></a>
                    </div>
                </div>
                -->

        </div>
        
        <!-- canvas für die bewegte Typoebene -->
        <canvas id="animCanvas" width="480" height="320"></canvas>
        
        <!-- load swiper -->
        <script src="resources/swiper.min.js"></script>
        <!-- initialized in jQuery when document ready -->

    <!-- ScrollReveal doesnt work with FullPage; hook the smooth reveal into scrollpage -->
    <!--
    <script src="https://unpkg.com/scrollreveal"></script>
    <script>
		ScrollReveal().reveal('.slide', {delay:200});
	</script>
    -->
        </div>
    <script>
        $(document).ready(function() {

            var colors = ["rgb(231,95,42)", "rgb(185,184,184)", "rgb(90,220,129)", "rgb(245,255,42)", "rgb(174,54,248)", "rgb(0,65,236)"];

            //Zufallsfunktion Farbe
            $('.randomcolor').each(function() {
                var number = 1 + Math.floor(Math.random() * 5);
                $(this).attr("style", "color:" + colors[number]);
            });

            //Zufallsfunktion Fotoposition
            $('.randompos').each(function() {
                var divWidth = $(this).outerHeight();
                var divHeight = $(this).outerWidth();
                $(this).attr("style", "left:" + (Math.random() * ($(window).width() - divWidth)).toFixed() + "px; top:" + (Math.random() * ($(window).height() - divHeight)).toFixed() + "px");
            });

            //SWIPER
            //initialize swiper when document ready
            var mySwiper = new Swiper('.swiper-container', {
                // Optional parameters
                direction: 'horizontal',
                loop: false,
                slidesPerView: 2,
                spaceBetween: 20,
                centeredSlides: true,
                centerInsufficientSlides: true,
                autoHeight: true,

                // Navigation arrows
                navigation: {
                    nextEl: '.swiper-button-next',
                    prevEl: '.swiper-button-prev',
                },

                // add these together with mobile css!
                breakpoints: {
                    // when window width is >= 320px
                    800: {
                        slidesPerView: 1,
                        spaceBetween: 10
                    },
                }
                /*
                //aspect ratio width/height of >=0.75
                '@0.75': {
                slidesPerView: 2,
                spaceBetween: 20,
                },
                }
                */

                /* BETTER instead of having multiple loading sliders: https://swiperjs.com/api/#virtual */
            });


            /* instantly collapse sliders at start! */
            $(".swiper-container").each(function() {
                $(this).slideToggle(0, function() {});
            });

            /* SLIDER für Galerien Expand*/


            $(".galeriecatg").each(function() {
                // child of this galeriecatg slides in/out
                $(this).click(function() {

                    // do this with slideUp() and slideDown() to return to start and stuff
                    $(this).find(".swiper-container").slideToggle("slow", function() {
                        // Animation complete.
                        mySwiper.slideNext(300);
                        //mySwiper.slideTo(0, 300);
                    });
                })
            });

            $(".galeriecatg").each(function() {
                // child of this galeriecatg slides in/out
                $(this).click(function() {

                    // do this with slideUp() and slideDown() to return to start and stuff
                    $(this).find(".coming-soon").slideToggle("slow", function() {
                        // Animation complete.
                    });
                    $(this).find(".dropIcon").toggleClass("rotate-180");
                })
            });
            
            //SCROLL LISTENER
            /*
            $(window).scroll(function() {
               if($(window).scrollTop() + $(window).height() == $(document).height()) {
                   alert("bottom!");
               }
            });
            */
        });
    </script>
    
    
    <!-- animated typo -->
    <!-- from https://www.html5canvastutorials.com/advanced/html5-canvas-bouncing-balls/ -->
    <script>
        $(document).ready(function() {
        
        var canvas = document.querySelector('#animCanvas');
        var ctx = canvas.getContext('2d');
        

        var width = canvas.width = window.innerWidth;
        var height = canvas.height = window.innerHeight;
        var delay = 200;   //delay between words coming onto screen

        var colors = ["rgb(245,255,42)", "rgb(185,184,184)", "rgb(90,220,129)", "rgb(174,54,248)", "rgb(231,95,42)", "rgb(0,65,236)"];
        var words = ["the", "end(s)", "of", "the", "world", "?"];
        var state = 0;  //0 ends; 1 galerie; 2 team; 3 see you soon;
        var wordCount = words.length;
        var word;
        var fontSize; //this is dynamic based on screen dimensions, filled in resizeCanvas()
        var targetFontSize;
        var minFontSize;    // the smallest the font should be, based on fontSize
        var maxFontSize;
        var letterSpacing = 0.85;
        if (window.screen.width * window.devicePixelRatio > window.screen.height * window.devicePixelRatio) {
                //console.log("width is bigger");
                fontSize = Math.round(height / 2);
                minFontSize = Math.round(fontSize / 4);
                maxFontSize = Math.round(fontSize);
            } else {
                //console.log("height is bigger");
                fontSize = Math.round(width / 3);
                minFontSize = Math.round(fontSize / 3);
                maxFontSize = Math.round(fontSize);
            }
        var fontStyle = "normal"; // normal or oblique, alternating on edgecollision
        var fontCase = 0; // 0: normal, 1: oblique
        ctx.font = "normal " + fontSize + "px PX Grotesk";
        ctx.font = "normal " + fontSize + "px PX Grotesk";
        ctx.strokeStyle = "black";
        
        var scroll; //gets scroll distance from top

        // function to generate random number
        function random(min, max) {
            var num = Math.floor(Math.random() * (max - min)) + min;
            // if min = 10 max = 15 random var = 0.1544465; it will return approzimately 10 because of math.floor
            return num;
        }
 
        function getMinTextWidth(text, minFontSize, fontStyle) {
            ctx.font = fontStyle + " " + minFontSize + "px PX Grotesk";
            ctx.fillText(text, 0, 0);
            var minTextWidth = ctx.measureText(text).width;
            var minTextWidth = (Math.abs(ctx.measureText(text).actualBoundingBoxLeft) + Math.abs(ctx.measureText(text).actualBoundingBoxRight));
            return minTextWidth;
        }
            
        function getMaxTextWidth(text, maxFontSize, fontStyle) {
            ctx.font = fontStyle + " " + maxFontSize + "px PX Grotesk";
            ctx.fillText(text, 0, 0);
            var maxTextWidth = ctx.measureText(text).width;
            var maxTextWidth = (Math.abs(ctx.measureText(text).actualBoundingBoxLeft) + Math.abs(ctx.measureText(text).actualBoundingBoxRight));
            return maxTextWidth;
        }
            
        // called after velocity inversion (edge detection), gets object's font style and inverts it
        function fontStyleChange(object) {
            var textStyle = object.fontStyle;
            if (textStyle == "normal") {
                textStyle = "oblique";
            } else {
                textStyle = "normal";
            }
            return textStyle;
        }

        function Ball(identifier) {
            this.x = random(0, -width);  //ONLY FOR INITIALIZATION; was 0, width; this spawns them only the first screen quarter, so no long word gets stuck
            this.y = random(0+fontSize, height); //was 0, height; but this makes thigns get stuck
            // move all things in from one side and out from another? this might help with creating intro & outro states
            this.velX = random(4, 7);  //was -7,7; now only positive to make things slide in from beyond the left canvas border
            this.velY = random(-7, 7);
            // edge case 2 do: if (-1 < velocity < 1 )
            this.color = colors[identifier];
            this.size = 1; //lower left edge, only for dev purposes
            this.word = words[identifier];
            this.index = identifier;
            this.fontStyle = "normal";
            this.textWidth = getMaxTextWidth(this.word, fontSize, this.fontStyle)*letterSpacing;    //deprecated, for initialization only
            this.defaultTextWidth = this.textWidth * letterSpacing;
            
            this.x = -this.textWidth*1.2;   //REAL spawn point outside of canvas based on final textWidth value
            
            this.introState = true; // true when spawning for as long as the word is outside the canvas bounds, to prevent getting stuck in velocity switching
            this.timeCount = 0;  //counting up to delay;
            
            // below: individual letters as child elements
            this.characters = Array.from(this.word);   //split word array into single letters
            this.letters=[];    //array to be filled with letter objects

            this.getLetters = function() {
                for (j=0;j<this.characters.length;j++) {    //don't use same countervar as the parent loop where this gets called!
                    var LetterFontStyle = "normal";
                    if (j % 2 === 0) { // index is even
                        LetterFontStyle = "oblique";
                    }
                    var letter = new Letter(this.characters[j],this.color,LetterFontStyle);
                    this.letters.push(letter);     
                }
                //console.log(this.letters);
            }
            
            this.widthChange = function() {
                var letterWidthSum= [];
                for (m=0;m<this.characters.length;m++) {
                    letterWidthSum.push(this.letters[m].maxTextWidth); 
                }
                var wordWidth = letterWidthSum.reduce(function (accumulator, currentValue) {
                      return accumulator + currentValue
                    }, 0) * letterSpacing;
                return wordWidth;
            }
            
            //this.textWidth = this.widthChange(); 
        }
        
        
        // this has to be nested inside the Ball constructor
        function Letter(character, color, fontStyle) {
            this.x = 0;  //relative to parent container origin: origin + this.margin + this.width
            this.y = random(-40,40);  //relative to parent container origin: origin + this.margin + this.height
            this.velX = 0;  
            this.velY = 0;
            this.margin; //maybe percentage of fontSize?
            this.color = color//inherit container Ball color; needed?
            this.letter = character;
            this.fontStyle = fontStyle;
            this.minTextWidth = getMinTextWidth(this.letter,minFontSize,this.fontStyle);
            this.maxTextWidth = getMaxTextWidth(this.letter,maxFontSize,this.fontStyle);
        }
        
        Letter.prototype.update = function() {
            //this is where things like individual letter movement get  calculated
            /* //fake code
            if (collision detected) {
                this.velX = Ball velX;
                this.velY = Ball velY;
                
                for (i=0; i<edgeTime; i++) {
                    //to make letter crouch together, this most likely needs the margin value, as well
                    this.x += velX;
                    this.y *= velY;
                }
            }
            */
        }
        
        Ball.prototype.draw = function() {
            ctx.beginPath();
            ctx.fillStyle = this.color;
            ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI); //text origin: bottom left corner (canvas gets drawn from top left)
            //ctx.strokeRect(this.x, this.y - fontSize, this.textWidth, fontSize); //object boundaries
            ctx.fill();
            ctx.font = this.fontStyle + " " + fontSize + "px PX Grotesk";
            ctx.lineWidth = 4;

            //NEW: FEATURING SINGLE LETTERS
            var textWidthSum = [];  //collects letter widths to get new start x for next letter
            for (k = 0; k < this.letters.length; k++) {
                var currX;
                currX = textWidthSum.reduce(function (accumulator, currentValue) {
                  return accumulator + currentValue
                }, 0) * letterSpacing;  // sum of all current textWidthSum array values multiplied with letter-spacing
                //console.log("currX: "+currX);
                //console.log(textWidthSum);
                ctx.fillText(
                    this.letters[k].letter, 
                    this.x + currX,
                    this.y + this.letters[k].y
                );
                
                ctx.strokeText(this.letters[k].letter, this.x + currX, this.y + this.letters[k].y);
                /*
                ctx.strokeRect(this.x + this.letters[k].x + (this.letters[k].maxTextWidth) * k,
                               this.y + this.letters[k].y - fontSize, 
                               this.letters[k].maxTextWidth,
                               fontSize
                              ); //object boundaries
                */     
                //ctx.strokeText(this.word, this.x, this.y);    //dev
                textWidthSum.push(this.letters[k].maxTextWidth);    // after letter gets drawn, add it's width to textWidthSum
            }
            
            //below: working word draw
            /*
            ctx.fillText(this.word, this.x, this.y);
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 4;
            ctx.strokeText(this.word, this.x, this.y);
            */
            
            this.return
        }

        Ball.prototype.update = function() {
            //compare right wordedge and right screenborder
            if ((this.x + this.textWidth) >= width) {
                this.velX = -(Math.abs(this.velX));
                this.velY = this.velY + random(-1,1);   //some randomness for the y-axis
                this.fontStyle = fontStyleChange(this);
            }
            
            // compare left wordedge and left screenborder
            if ((this.x/* - this.textWidth*/) <= 0 && this.introState==false) {
                this.velX = Math.abs(this.velX);
                this.fontStyle = fontStyleChange(this);
            } else if (this.x > 2){
                this.introState = false
            }

            // compare font baseline with bottom screenedge
            if ((this.y + this.size) >= height) {
                this.velY = -(this.velY);
                this.fontStyle = fontStyleChange(this);
            }

            // compare font height with top screenedge; font boundaries are larger than visuals, so reduce a bit
            if ((this.y - (fontSize/1.5)) <= 0) {
                this.velY = Math.abs(this.velY);
                this.fontStyle = fontStyleChange(this);
            }

            if (this.timeCount >= delay * this.index+1) {
                this.x += this.velX;
                this.y += this.velY;
            } else {
                this.timeCount++;
                //console.log("timeCount: "+this.timeCount+ "; index: "+this.index);
            }
            
            if (fontSize > targetFontSize) {
                fontSize--;
            }  else if (fontSize == targetFontSize) {
                targetFontSize = fontSize;
            }  else if (fontSize < targetFontSize) {
                fontSize++;
            }
            
            /*
            if(scroll>0.1){
                fontSize = fontSize*scroll;
            }
            */
        }
        
        var balls = [];
        
        //below: seemingly unused by orig code?
        /*
        Ball.prototype.collisionDetect = function() {
            for (j = 0; j < balls.length; j++) {
                if ((!(this.x === balls[j].x && this.y === balls[j].y && this.velX === balls[j].velX && this.velY === balls[j].velY))) {
                    var dx = this.x - balls[j].x;
                    var dy = this.y - balls[j].y;
                    var distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < this.size + balls[j].size) {
                        balls[j].color = this.color = 'rgb(' + random(0, 255) + ',' + random(0, 255) + ',' + random(0, 255) + ')';
                    }
                }
            }
        }
        */

        
        function loop() {
            ctx.clearRect(0, 0, width, height);

            while (balls.length < wordCount) {
                for (i = 0; i < wordCount; i++) {
                    var ball = new Ball(i);
                    ball.getLetters();
                    //console.log(ball);
                    balls.push(ball);
                }
                /*
                for (i=0; i < wordCount; i++) { //this somehow only fills out two words' letters, why? 
                    //balls[i].getLetters();
                    console.log(balls[i]);
                }
                */
            }

            for (i = 0; i < balls.length; i++) {
                balls[i].draw();
                balls[i].update();
            }
            
            // this is shitty, but works mostly
            window.onscroll = function() {scrollFunction()};
            function scrollFunction() {
              if (document.body.scrollTop > 80 || document.documentElement.scrollTop > 80) {
                    targetFontSize = minFontSize;
                      
                    for (i=0;i<wordCount;i++){
                        balls[i].textWidth = balls[i].widthChange(); 
                    }
                      
              } else if (document.body.scrollTop < 81 || document.documentElement.scrollTop < 81) {
                      targetFontSize = maxFontSize;
                  
                    for (i=0;i<wordCount;i++){
                        balls[i].textWidth = balls[i].widthChange(); 
                    }
              }
            }

            requestAnimationFrame(loop);
        }
        
        loop();
        
        initialize();
        
            
        function initialize() {
           // Register an event listener to call the resizeCanvas() function 
           // each time the window is resized.
           window.addEventListener('resize', resizeCanvas, false);
           // Draw canvas border for the first time.
           resizeCanvas();
        }
        
        // Runs each time the DOM window resize event fires.
        // Resets the canvas dimensions to match window,
        // then draws the new borders accordingly.
        function resizeCanvas() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            
            if (window.screen.width * window.devicePixelRatio > window.screen.height * window.devicePixelRatio) {
                //console.log("width is bigger");
                fontSize = Math.round(height / 2);
                minFontSize = Math.round(fontSize / 4);
            } else {
                //console.log("height is bigger");
                fontSize = Math.round(width / 2);
                minFontSize = Math.round(fontSize / 4);
            }
        }
             
        });
    </script>
	
</body>

</html>