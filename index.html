<!DOCTYPE html>
<html lang="de">

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>Rundgang Finkenau 2020</title>
        <meta name="description" content="Rundgang Finkenau – Sommer 2020">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="resources/style.css">
        <link rel="icon" type="image/x-icon" href="resources/favicon.ico">
        <style class="__css_exfil_protection_filtered_styles"></style>
        
        <link rel="stylesheet" href="resources/swiper.min.css">
        
        <script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
        
        <!-- Matomo -->
        <script type="text/javascript">
            if (location.hostname.includes("haw-hamburg.de") || location.hostname === "141.22.177.246") {
                var _paq = window._paq || [];
                /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
                _paq.push(['trackPageView']);
                _paq.push(['enableLinkTracking']);
                (function() {
                    var u = "https://matomo.design.haw-hamburg.de/";
                    _paq.push(['setTrackerUrl', u + 'matomo.php']);
                    _paq.push(['setSiteId', '10']);
                    var d = document,
                        g = d.createElement('script'),
                        s = d.getElementsByTagName('script')[0];
                    g.type = 'text/javascript';
                    g.async = true;
                    g.defer = true;
                    g.src = u + 'matomo.js';
                    s.parentNode.insertBefore(g, s);
                })();
            }
        </script>
        <!-- End Matomo Code -->
        
    </head>

    <body>
        <div id="fullpage">

            <div id="landingcanvas">
                <div class="footer-link" style="margin:0.25em;position:absolute;top:0;right:0;font-size:4em;">
                        <a target="_blank" href="https://design.haw-hamburg.de/home/das-department-design/">
                        <img class="footerlogo" src="resources/haw-logo.svg" alt="HAW Hamburg"></a>
                </div>
            </div>

            <div class="section content-block" id="eingangstext">
                <div class="slide">
                    <h3 class="green">The end(s) of the world?</h3>
                    <p class="textblock">Stehen wir am Ende der Welt? Oder an einem Ende? Welche Welt könnte hier enden? Oder ist nicht vielmehr so: Corona zeigt, wie alle Enden der Welt zusammenhängen? Zusammenhänge werden offensichtlich. Die Welt ist eine Kugel. Es geht immer weiter, nur anders.</p>
                </div>

                <div class="slide">
                    <h3  class="grey">Wer wir sind </h3>
                    <p class="textblock">Angehende Kommunikationsdesigner*innen, die mit Blick auf eine aktuell schwer planbare Zukunft nach der praktischen Rolle von Design fragen. Im Sommersemester 2020 wollten wir das Erscheinungsbild für den Rundgang Finkenau gestalten, der am Ende des Semesters auf dem Kunst- und Mediencampus Hamburg stattfinden sollte. Die Sommerausstellung zeigt jedes Jahr Studien- und Abschlussarbeiten aus den Departments Design, Medientechnik und Information.<br> Jedoch nicht in diesem Jahr. Corona hat alles auf den Kopf gestellt und zu ganz anderen Fragestellungen geführt. </p>
                </div>

                <div class="slide">
                    <h3  class="yellow">Stillstand oder Aufbruch?</h3>
                    <p class="textblock">Statt ein Erscheinungsbild zu kreieren, stellen wir eine kryptische Frage. Wir wollen wissen, wie wir reagieren. Auf ein Ende der Welt. Erstarren wir? Fühlen wir Angst? Oder wählen wir Taten und Aktionismus? Initiieren wir einen Neustart? Trauen wir uns, Visionen von Hoffnung zu kreieren? Für alle. Sicher ist: wir wollen weiter machen. Auch in der Krise sind wir kreativ.</p>
                </div>

                <div class="slide">
                    <h3  class="blue">Allein oder zusammen? </h3>
                    <p class="textblock">Wie entsteht kreatives Arbeiten? Gelingt es in Stille? Ohne Austausch mit anderen? Können Strukturen helfen, kreative Prozesse in Gang zu setzen? Oder kommt alles aus uns heraus? Irgendwann. Das Semester begann mit dem Lockdown. Am Anfang war alles eng. Allein am Schreibtisch, ohne Freund*innen, ohne Kommiliton*innen. Lehre über den Bildschirm. Arbeiten, hadern, forschen, wieder anfangen, noch mal von vorne. Gegen den Stillstand. Vieles funktioniert in der digitalen Welt. Aber nicht alles. Und nichts kann das direkte Gespräch ersetzen. </p>
                </div>

                <div class="slide">
                    <h3  class="orange">Wenn Corona das Internet verschluckt?</h3>
                    <p class="textblock">Wo wären wir ohne Zoom, ohne Teams, ohne E-Mails, ohne Online-Calls? Wenn wir digital nicht verbunden wären, was würden wir wählen? Würden wir mal wieder Briefe oder Postkarten schreiben? Ja, denn wir wollen miteinander im Gespräch bleiben. </p>
                </div>

                <div class="slide">
                    <h3  class="green">Die eine Antwort gibt es nicht.</h3>
                    <p class="textblock">Die Frage nach den Enden der Welt übersetzen wir in buntes typografisches Bild mit Lust auf Farbe. Die Buchstaben sind eng ins Format gedrängt, als hätten sie zu wenig Platz im Homeoffice. Die Pixelcursor spiegeln den momentanen Umgang mit digitalen Medien wider: Manchmal wirkt es so, als benutzen wir zum ersten Mal das Internet. Oder? </p>
                </div>
            </div>
            
            <div class="section content-block" style="margin:2em 0" id="armgart">
                <h1 class="green bordered">Rundgang Finkenau 2020</h1>
                <p class="textblock">Die diesjährige Sommerausstellung findet aufgrund der Pandemie leider nicht statt.</p>
            </div>
            
            <div class="section paddingless" id="fotocarousel">
                                
                <div class="galeriecatg marginchild">
                    <h2 class="blue"><span class="dropIcon">↓</span> Stadtrundgang</h2>
                    <div class="coming-soon" style="display:none;"><p>Coming soon!</p></div>
                    <!--
                    <div class="swiper-container">
                        <div class="swiper-wrapper">
                            <div class="swiper-slide"></div>
                            <div class="swiper-slide"><img src="img/litfass.png" class=foto></div>
                            <div class="swiper-slide"><img src="img/billboard.png" class=foto></div>
                            <div class="swiper-slide"><img src="img/litfass.png" class=foto></div>
                            <div class="swiper-slide"><img src="img/subway-ad.png" class=foto></div>
                        </div>
                        <div class="swiper-button-prev"></div>
                        <div class="swiper-button-next"></div>
                    </div>
                    -->
                </div>
                
                <div class="galeriecatg marginchild">
                    <h2 class="green"><span class="dropIcon">↓</span> Social Media</h2>
                    <div class="coming-soon" style="display:none;"><p>Coming soon!</p></div>
                </div>
                
                <div class="galeriecatg marginchild">
                    <h2 class="grey"><span class="dropIcon">↓</span> Rundgang 2019/20</h2>
                    <div class="coming-soon" style="display:none;"><p>Coming soon!</p></div>
                </div>
                                
            </div>
            
            <div class="section content-block" id="team">
                
                <h1 class="marginless green bordered">Team</h1>
                <div class="content_text">
                    <p>Das Erscheinungsbild des Rundgang Finkenau 2020 wurde von Studierenden des Studiengang Kommunikationsdesign an der Fakultät DMI der HAW Hamburg unter der Leitung von Paul Rutrecht und Hendrike Schmietendorf gestaltet: Frederik Engelbrecht, Georg Randel, Janna Thaden, Laura Dunse, Mert Ekinci, Rebecca Söhlke.</p>
                    <table id="teamtable">
                        <tr>
                            <th><h2 class="orange bordered">Studierende</h2></th>
                        </tr>
                        <tr>
                            <td>Georg Randel</td>
                            <td>georg.randel@yahoo.de</td>
                        </tr>
                        <tr>
                            <td>Janna Thaden</td>
                            <td>janna.thaden@gmx.net</td>
                        </tr>
                        <tr>
                            <td>Laura Dunse</td>
                            <td>laura.dunse@gmx.de</td>
                        </tr>
                        <tr>
                            <td>Mert Ekinci</td>
                            <td>mert.ekinci@haw-hamburg.de</td>
                        </tr>
                        <tr>
                            <td>Rebecca Söhlke</td>
                            <td>rebeccasoehlke@web.de</td>
                        </tr>
                        <tr>
                            <th><h2 class="lila bordered">Code</h2></th>
                        </tr>
                        <tr>
                            <td>Frederik Engelbrecht</td>
                            <td>fre.engelbrecht@gmail.com</td>
                        </tr>
                        <tr>
                            <th><h2 class="blue bordered">Betreuung</h2></th>
                        </tr>
                        <tr>
                            <td>Paul Rutrecht</td>
                            <td>mail@paulrutrecht.de</td>
                        </tr>
                        <tr>
                            <th><h2 class="grey bordered">Kommunikation</h2></th>
                        </tr>
                        <tr>
                            <td>Hendrike Schmietendorf</td>
                            <td>hendrike.schmietendorf@haw-hamburg.de</td>
                        </tr>
                    </table>
                </div>
                
            </div>
            
            <div class="section content-block spacer-top" id="armgart">
                <h1 class="green bordered">Ausblick</h1>
                <p class="textblock">Wir freuen uns darauf, euch auf dem Rundgang Armgartstraße Anfang 2021 wieder alle dort zu treffen. Sobald ein genauerer Termin feststeht, informieren wir euch hier und über die sozialen Medien!</p>
                <!-- <p class="textblock"><a href="">Erinner' mich dran, sobald es ein Datum gibt!</a></p>   -->
                <!--<div id="backtotop"><a href="#">↑</a></div>-->
                <div id="backtotop" onclick='window.scrollTo({top: 0, behavior: "smooth"});'>↑</div>
            </div>
            
            <div id="footer">
                    <div class="footer-link"><a href="impressum.html">Impressum & Datenschutz</a></div>
                    <div class="footer-link"><a href="https://www.instagram.com/haw_dmi/">Instagram</a></div>
                    <div class="footer-link"><a href="https://www.facebook.com/HAW.DMI">Facebook</a></div>
                <!--
                    <div class="footer-link">
                        <a class="smicon" target="_blank" href="https://design.haw-hamburg.de/home/das-department-design/">
                        <img class="footerlogo" src="resources/haw-logo.svg" alt="HAW Hamburg"></a>
                    </div>
                </div>
                -->

        </div>
        
        <!-- canvas für die bewegte Typoebene -->
        <canvas id="animCanvas" width="480" height="320"></canvas>
        
        <!-- load swiper -->
        <script src="resources/swiper.min.js"></script>
        <!-- initialized in jQuery when document ready -->

    <!-- ScrollReveal doesnt work with FullPage; hook the smooth reveal into scrollpage -->
    <!--
    <script src="https://unpkg.com/scrollreveal"></script>
    <script>
		ScrollReveal().reveal('.slide', {delay:200});
	</script>
    -->
        </div>
    <script>
        $(document).ready(function() {

            var colors = ["rgb(231,95,42)", "rgb(185,184,184)", "rgb(90,220,129)", "rgb(245,255,42)", "rgb(174,54,248)", "rgb(0,65,236)"];

            //Zufallsfunktion Farbe
            $('.randomcolor').each(function() {
                var number = 1 + Math.floor(Math.random() * 5);
                $(this).attr("style", "color:" + colors[number]);
            });

            //Zufallsfunktion Fotoposition
            $('.randompos').each(function() {
                var divWidth = $(this).outerHeight();
                var divHeight = $(this).outerWidth();
                $(this).attr("style", "left:" + (Math.random() * ($(window).width() - divWidth)).toFixed() + "px; top:" + (Math.random() * ($(window).height() - divHeight)).toFixed() + "px");
            });

            //SWIPER
            //initialize swiper when document ready
            var mySwiper = new Swiper('.swiper-container', {
                // Optional parameters
                direction: 'horizontal',
                loop: false,
                slidesPerView: 2,
                spaceBetween: 20,
                centeredSlides: true,
                centerInsufficientSlides: true,
                autoHeight: true,

                // Navigation arrows
                navigation: {
                    nextEl: '.swiper-button-next',
                    prevEl: '.swiper-button-prev',
                },

                // add these together with mobile css!
                breakpoints: {
                    // when window width is >= 320px
                    800: {
                        slidesPerView: 1,
                        spaceBetween: 10
                    },
                }
                /*
                //aspect ratio width/height of >=0.75
                '@0.75': {
                slidesPerView: 2,
                spaceBetween: 20,
                },
                }
                */

                /* BETTER instead of having multiple loading sliders: https://swiperjs.com/api/#virtual */
            });


            /* instantly collapse sliders at start! */
            $(".swiper-container").each(function() {
                $(this).slideToggle(0, function() {});
            });

            /* SLIDER für Galerien Expand*/


            $(".galeriecatg").each(function() {
                // child of this galeriecatg slides in/out
                $(this).click(function() {

                    // do this with slideUp() and slideDown() to return to start and stuff
                    $(this).find(".swiper-container").slideToggle("slow", function() {
                        // Animation complete.
                        mySwiper.slideNext(300);
                        //mySwiper.slideTo(0, 300);
                    });
                })
            });

            $(".galeriecatg").each(function() {
                // child of this galeriecatg slides in/out
                $(this).click(function() {

                    // do this with slideUp() and slideDown() to return to start and stuff
                    $(this).find(".coming-soon").slideToggle("slow", function() {
                        // Animation complete.
                    });
                    $(this).find(".dropIcon").toggleClass("rotate-180");
                })
            });
            
            //SCROLL LISTENER
            /*
            $(window).scroll(function() {
               if($(window).scrollTop() + $(window).height() == $(document).height()) {
                   alert("bottom!");
               }
            });
            */
        });
    </script>
    
    
    <!-- animated typo -->
    <!-- from https://www.html5canvastutorials.com/advanced/html5-canvas-bouncing-balls/ -->
    <script>
        $(document).ready(function() {
        
        var canvas = document.querySelector('#animCanvas');
        var ctx = canvas.getContext('2d');
        

        var width = canvas.width = window.innerWidth;
        var height = canvas.height = window.innerHeight;
        var delay = 200;   //delay between words coming onto screen

        var colors = ["rgb(245,255,42)", "rgb(185,184,184)", "rgb(90,220,129)", "rgb(174,54,248)", "rgb(231,95,42)", "rgb(0,65,236)"];
        var words = ["the", "end(s)", "of", "the", "world", "?"];
        var state = 0;  //0 ends; 1 galerie; 2 team; 3 see you soon;
        var wordCount = words.length;
        var word;
        var fontSize; //this is dynamic based on screen dimensions, filled in resizeCanvas()
        var targetFontSize; // the value to grow/shrink fontSize to
        var minFontSize;    // the smallest the font should be, based on fontSize
        var maxFontSize;
        var letterSpacing = 0.85;
        var letterEasing = 0.05;    //amount of easing when letters jump to new positions on edgeCollision
        if (window.screen.width * window.devicePixelRatio > window.screen.height * window.devicePixelRatio) {
                //console.log("width is bigger");
                fontSize = Math.round(height / 2);
                minFontSize = Math.round(fontSize / 4);
                maxFontSize = Math.round(fontSize);
            } else {
                //console.log("height is bigger");
                fontSize = Math.round(width / 3);
                minFontSize = Math.round(fontSize / 3);
                maxFontSize = Math.round(fontSize);
            }
        var verticalOffsetMult = minFontSize / maxFontSize; // used for letter y-offset when scaling
        var fontStyle = "normal"; // normal or oblique, alternating on edgecollision
        var fontCase = 0; // 0: normal, 1: oblique
        ctx.font = "normal " + fontSize + "px PX Grotesk";
        ctx.font = "normal " + fontSize + "px PX Grotesk";
        ctx.strokeStyle = "black";
        var minLineWidth = 1.5;
        var maxLineWidth = 4.0;
        var lineWidth = maxLineWidth;
        var targetLineWidth = maxLineWidth;
        
        var scroll; //gets scroll distance from top

        // function to generate random number
        function random(min, max) {
            var num = Math.floor(Math.random() * (max - min)) + min;
            // if min = 10 max = 15 random var = 0.1544465; it will return approzimately 10 because of math.floor
            return num;
        }
            
        function humanize(x){
          return x.toFixed(2).replace(/\?0*$/,'');
        }
 
        function getMinTextWidth(object) {
            var text;
            var localLetterSpacing = 1;
            if(object.hasOwnProperty("word")){  //if passed object is word
                text = object.word;
                localLetterSpacing = letterSpacing;
                //console.log(letterSpacing);
            } else if (object.hasOwnProperty("letter")) {   //if passed object is letter
                text = object.letter;
            }
            //var text = object.word || object.letter;
            //var minFontSize = minFontSize;
            var fontStyle = object.fontStyle;
            ctx.font = fontStyle + " " + minFontSize + "px PX Grotesk";
            ctx.fillText(text, 0, 0);
            var newMinTextWidth = Math.round(ctx.measureText(text).width*localLetterSpacing);
            //var minTextWidth = (Math.abs(ctx.measureText(text).actualBoundingBoxLeft) + Math.abs(ctx.measureText(text).actualBoundingBoxRight));
            //console.log("returned minTextWidth: "+newMinTextWidth);
            return newMinTextWidth;
        }
        function getMaxTextWidth(object) {
            var text;
            var localLetterSpacing = 1;
            if(object.hasOwnProperty("word")){
                text = object.word;
                localLetterSpacing = letterSpacing;
            } else if (object.hasOwnProperty("letter")) {
                text = object.letter;
            }
            //var maxFontSize = maxFontSize;
            var fontStyle = object.fontStyle;
            ctx.font = fontStyle + " " + maxFontSize + "px PX Grotesk";
            ctx.fillText(text, 0, 0);
            var newMaxTextWidth = Math.round(ctx.measureText(text).width*localLetterSpacing);
            //var maxTextWidth = (Math.abs(ctx.measureText(text).actualBoundingBoxLeft) + Math.abs(ctx.measureText(text).actualBoundingBoxRight));
            //console.log("returned maxTextWidth: "+newMaxTextWidth);
            return newMaxTextWidth;
        }
            //below: work, but instead just pass the object
            /*
        function getMinTextWidth(text, minFontSize, fontStyle) {
            ctx.font = fontStyle + " " + minFontSize + "px PX Grotesk";
            ctx.fillText(text, 0, 0);
            var minTextWidth = ctx.measureText(text).width;
            var minTextWidth = (Math.abs(ctx.measureText(text).actualBoundingBoxLeft) + Math.abs(ctx.measureText(text).actualBoundingBoxRight));
            return minTextWidth;
        }
            
        function getMaxTextWidth(text, maxFontSize, fontStyle) {
            ctx.font = fontStyle + " " + maxFontSize + "px PX Grotesk";
            ctx.fillText(text, 0, 0);
            var maxTextWidth = ctx.measureText(text).width;
            var maxTextWidth = (Math.abs(ctx.measureText(text).actualBoundingBoxLeft) + Math.abs(ctx.measureText(text).actualBoundingBoxRight));
            return maxTextWidth;
        }
        */
            
        // called after velocity inversion (edge detection), gets object's font style and inverts it
        function fontStyleChange(object) {
            /*
            var textStyle = object.fontStyle;
            if (textStyle == "normal") {
                textStyle = "oblique";
            } else {
                textStyle = "normal";
            }
            return textStyle;
            */
            //rewritten to apply to child letter object instead of word
            var letterCount = object.letters.length;
            for (n=0;n<letterCount;n++) {
                var currLett = object.letters[n];
                var textStyle = currLett.fontStyle;
                if (textStyle == "normal") {
                    textStyle = "oblique";
                } else {
                    textStyle = "normal";
                }
                currLett.fontStyle = textStyle;
            }
        }
            
            function letterPosChange(object) {
                var letterCount = object.letters.length;
                for (q=0;q<letterCount;q++) {
                    var currLett = object.letters[q];
                    var fontSizeMult = (fontSize * verticalOffsetMult)*0.1; //scaling factor to account for min-max fontSize
                    currLett.newY = random(-5*fontSizeMult,5*fontSizeMult);
                    currLett.newX = random(-2*fontSizeMult,2*fontSizeMult); //slightly smaller valuespace to keep readable
                }
            }
            
        //used on Ball words, calculates the child letters' width, sums them and returns the new width
        function widthChange(object, mode) {
            var letterWidthSum= []; //array to store all child letters' width
            var characterCount = object.characters.length;
            var newWidth;   //this is the target width?
            var text = object.word;
            var arbitraryValue = 0.1;   //subtracted from letterSpacing because the calculated with is a bit too large
            /*
            if (mode == "grow") {
                var fontStyle = object.fontStyle;
                ctx.font = fontStyle + " " + maxFontSize + "px PX Grotesk";
                ctx.fillText(text, 0, 0);
                var newMaxTextWidth = Math.round(ctx.measureText(text).width*letterSpacing);
                //var maxTextWidth = (Math.abs(ctx.measureText(text).actualBoundingBoxLeft) + Math.abs(ctx.measureText(text).actualBoundingBoxRight));
                //console.log("returned maxTextWidth: "+newMaxTextWidth);
                newWidth = newMaxTextWidth;
            } else if (mode == "shrink") {
                var fontStyle = object.fontStyle;
                ctx.font = fontStyle + " " + minFontSize + "px PX Grotesk";
                ctx.fillText(text, 0, 0);
                var newMinTextWidth = Math.round(ctx.measureText(text).width*(letterSpacing-0.1));
                //var maxTextWidth = (Math.abs(ctx.measureText(text).actualBoundingBoxLeft) + Math.abs(ctx.measureText(text).actualBoundingBoxRight));
                //console.log("returned maxTextWidth: "+newMaxTextWidth);
                newWidth = newMinTextWidth;
            }
            return newWidth;*/
            //below: method that sums every letter's width and multiplies that with letterPsacing value; but this is wider than the initialized width
            
            if (mode == "grow") {
                for (m=0;m<characterCount;m++) {
                    var currLetter = object.letters[m];
                    //object.letters[m].getMaxTextWidth(currLetter.letter,currLetter.maxFontSize,currLetter.fontStyle)  //old function used
                    newWidth = getMaxTextWidth(currLetter);
                    //console.log(currLetter.letter+" growing to: "+newWidth);
                    letterWidthSum.push(newWidth); 
                }
            } else if (mode == "shrink") {
                for (m=0;m<characterCount;m++) {
                    var currLetter = object.letters[m];
                    newWidth = getMinTextWidth(currLetter);
                    //console.log(currLetter.letter+" shrinking to: "+newWidth);
                    letterWidthSum.push(newWidth); 
                }
            }
            var wordWidth = letterWidthSum.reduce(function (accumulator, currentValue) {
                    return accumulator + currentValue
                }, 0) * (letterSpacing-arbitraryValue);
            //console.log("widthChange for "+object.word+" returns "+wordWidth);
            return wordWidth;   //this works!
            
            //object.textWidth = wordWidth;
        }
            
        //below: unused
            /*
        function letterWidthChange(object, mode) {
            var mode = mode;
            var newWidth;   //this is the target width?
            if (mode == "grow") {
                object.targetLetterWidth = object.maxTextWidth;
                newWidth = object.maxTextWidth;
            } else if (mode == "shrink") {
                object.targetLetterWidth = object.minTextWidth;
                newWidth = object.minTextWidth;
            }
            //console.log("letterWidthchange new width:"+newWidth);
            return newWidth;
        }
        */

        function Ball(identifier) {
            this.x = random(0, -width);  //ONLY FOR INITIALIZATION; was 0, width; this spawns them only the first screen quarter, so no long word gets stuck
            this.y = random(0+fontSize, height); //was 0, height; but this makes thigns get stuck
            // move all things in from one side and out from another? this might help with creating intro & outro states
            this.velX = random(4, 4);  //was -7,7; now only positive to make things slide in from beyond the left canvas border
            this.velY = random(-4, 4);
            // edge case 2 do: if (-1 < velocity < 1 )
            this.color = colors[identifier];
            this.size = 1; //lower left edge, only for dev purposes
            this.word = words[identifier];
            this.index = identifier;
            this.fontStyle = "normal";
            this.textWidth = Math.round(getMaxTextWidth(this));    // for initialization only
            this.targetTextWidth = Math.round(this.textWidth);  // gets changed on scroll to grow/ shrink letter spacing & word boundaries
            this.minTextWidth = Math.round(getMinTextWidth(this));
            this.maxTextWidth = Math.round(getMaxTextWidth(this));
            
            this.x = -this.textWidth*1.3;   //REAL spawn point outside of canvas based on final textWidth value
            
            this.introState = true; // true when spawning for as long as the word is outside the canvas bounds, to prevent getting stuck in velocity switching
            this.timeCount = 0;  //counting up to delay;
            
            // below: individual letters as child elements
            this.characters = Array.from(this.word);   //split word array into single letters
            this.letters=[];    //array to be filled with letter objects

            this.getLetters = function() {
                var charCount = this.characters.length;
                var LetterFontStyle;
                
                for (j=0;j<charCount;j++) {    //don't use same countervar as the parent loop where this gets called!
                    if (j % 2 === 0) { // index is even
                        LetterFontStyle = "oblique"; 
                    } else { LetterFontStyle = "normal" }
                    var letter = new Letter(this.characters[j],this.color,LetterFontStyle);
                    this.letters.push(letter);     
                }
                //console.log(this.letters);
            }
            
            //below: widthChange as method, but needs to be function with parms
            /*
            this.widthChange = function() {
                var letterWidthSum= [];
                if (mode == grow) {
                    for (m=0;m<this.characters.length;m++) {
                        letterWidthSum.push(this.letters[m].maxTextWidth); 
                    }
                } else if (mode == shrink) {
                    var letterWidthSumMin= [];
                    for (m=0;m<this.characters.length;m++) {
                        letterWidthSum.push(this.letters[m].minTextWidth); 
                    }
                }
                var wordWidth = letterWidthSum.reduce(function (accumulator, currentValue) {
                      return accumulator + currentValue
                    }, 0) * letterSpacing;
                return wordWidth;
                this.textWidth = wordWidth;
            }
            */
            
            //this.textWidth = this.widthChange(); 
        }
        
        
        // this has to be nested inside the Ball constructor
        function Letter(character, color, localFontStyle) {
            this.x = 0;  //relative to parent container origin: origin + this.margin + this.width
            this.y = random(-40,40);  //relative to parent container origin: origin + this.margin + this.height
            this.newX = this.x;
            this.newY = this.y;
            this.origY = this.y;
            this.velX = 0;  
            this.velY = 0;
            this.margin; //maybe percentage of fontSize?
            this.color = color//inherit container Ball color; needed?
            this.letter = character;
            this.fontStyle = localFontStyle;
            this.minTextWidth = getMinTextWidth(this);
            //console.log("min: "+this.minTextWidth);
            this.maxTextWidth = getMaxTextWidth(this);
            //console.log("max: "+this.maxTextWidth);
            this.letterWidth = this.maxTextWidth;     //initial, since text starts big
            this.targetLetterWidth = this.maxTextWidth;
        }
        
        Letter.prototype.update = function() {
            if (this.letterWidth < this.targetLetterWidth) {
                this.letterWidth++;
                this.y = this.origY;
            } else if (this.letterWidth > this.targetLetterWidth) {
                this.letterWidth--;
                this.targetY = this.origY*verticalOffsetMult;
                if (this.y > this.targetY) {
                    this.y = this.y * verticalOffsetMult;
                }
            }
            
            if (this.x < this.newX) {
                //var dx = this.newX-this.x;
                //this.x += dx*letterEasing;
                this.x++;
            } else if (this.x > this.newX) {
                //var dx = this.newX-this.x;
                //this.x -= dx*letterEasing;
                this.x--;
            }
            if (this.y < this.newY) {
                //this.y++;
                var dy = this.newY-this.y;
                this.y += dy*letterEasing;
            } else if (this.y > this.newY) {
                //this.y--;
                var dy = this.newY-this.y;
                this.y += dy*letterEasing;  //this makes the letters fall down, offscreen - maybe useful for a remove animation?
            }
            //this is where things like individual letter movement get  calculated
            /* //fake code
            if (collision detected) {
                this.velX = Ball velX;
                this.velY = Ball velY;
                
                for (i=0; i<edgeTime; i++) {
                    //to make letter crouch together, this most likely needs the margin value, as well
                    this.x += velX;
                    this.y *= velY;
                }
            }
            */
        }
        
        Ball.prototype.draw = function() {
            ctx.beginPath();
            ctx.fillStyle = this.color;
            //ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI); //text origin: bottom left corner (canvas gets drawn from top left)
            //ctx.strokeRect(this.x, this.y - fontSize, this.textWidth, fontSize); //object boundaries
            //ctx.strokeRect(this.x, this.y - fontSize, this.textWidth, fontSize);
            ctx.fill();
            //ctx.font = this.fontStyle + " " + fontSize + "px PX Grotesk"; //works, but assigns single fontstyle to all letters
            ctx.lineWidth = lineWidth;  //has to be dynamic

            //NEW: FEATURING SINGLE LETTERS
            var textWidthSum = [];  //collects letter widths to get new start x for next letter
            var letterCount = this.letters.length;
            for (k = 0; k < letterCount; k++) {
                ctx.font = this.letters[k].fontStyle + " " + fontSize + "px PX Grotesk";
                var currX;
                currX = textWidthSum.reduce(function (accumulator, currentValue) {
                  return accumulator + currentValue
                }, 0) * letterSpacing;  // sum of all current textWidthSum array values multiplied with letter-spacing
                //console.log("currX: "+currX);
                //console.log(textWidthSum);
                ctx.fillText(
                    this.letters[k].letter, 
                    this.x + this.letters[k].x + currX,
                    this.y + this.letters[k].y
                );
                
                ctx.strokeText(this.letters[k].letter, this.x + this.letters[k].x + currX, this.y + this.letters[k].y);
                /*
                ctx.strokeRect(this.x + this.letters[k].x + (this.letters[k].maxTextWidth) * k,
                               this.y + this.letters[k].y - fontSize, 
                               this.letters[k].maxTextWidth,
                               fontSize
                              ); //object boundaries
                */     
                //ctx.strokeText(this.word, this.x, this.y);    //dev
                //below: dont use maxTextWidth, use dynamic value!
                textWidthSum.push(this.letters[k].letterWidth);    // after letter gets drawn, add it's width to textWidthSum
            }
            
            //below: working word draw
            /*
            ctx.fillText(this.word, this.x, this.y);
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 4;
            ctx.strokeText(this.word, this.x, this.y);
            */
            
            //this.return
        }

        Ball.prototype.update = function() {
            //compare right wordedge and right screenborder
            if ((this.x + this.textWidth) >= width) {
                this.velX = -(Math.abs(this.velX));
                this.velY = this.velY + random(-1,1);   //some randomness for the y-axis
                this.fontStyle = fontStyleChange(this);
                letterPosChange(this);
            }
            
            // compare left wordedge and left screenborder
            if ((this.x/* - this.textWidth*/) <= 0 && this.introState==false) {
                this.velX = Math.abs(this.velX);
                this.fontStyle = fontStyleChange(this);
                letterPosChange(this);
            } else if (this.x > 2){
                this.introState = false
            }

            // compare font baseline with bottom screenedge
            if ((this.y + this.size) >= height) {
                this.velY = -(this.velY);
                this.fontStyle = fontStyleChange(this);
                letterPosChange(this);
            }

            // compare font height with top screenedge; font boundaries are larger than visuals, so reduce a bit
            if ((this.y - (fontSize/1.5)) <= 0) {
                this.velY = Math.abs(this.velY);
                this.fontStyle = fontStyleChange(this);
                letterPosChange(this);
            }

            if (this.timeCount >= delay * this.index+1) {
                this.x += this.velX;
                this.y += this.velY;
            } else {
                this.timeCount++;
                //console.log("timeCount: "+this.timeCount+ "; index: "+this.index);
            }
            
            if (fontSize > targetFontSize) {
                fontSize--;
            }  else if (fontSize == targetFontSize) {
                targetFontSize = fontSize;
            }  else if (fontSize < targetFontSize) {
                fontSize++;
            }
            
            //console.log(this.word+" textWidth: "+this.textWidth+" targetTextWidth: "+this.targetTextWidth);
            //below: works, but lags behind visible letter positions - increase? clamp value to even, then increase in two?
            if (/*this.minTextWidth > */this.textWidth > this.targetTextWidth) {
                this.textWidth--;
                this.textWidth = this.targetTextWidth;
            } else if (this.textWidth == this.targetTextWidth) {
                this.targetTextWidth = this.textWidth;
            } else if (this.textWidth < this.targetTextWidth) {
                this.textWidth++;
                this.textWidth = this.textWidth +1.5;
                //this.textWidth = this.targetTextWidth;
            }
            
            if (lineWidth < targetLineWidth) {
                //lineWidth += 0.01;
                lineWidth = (lineWidth * 100 + 0.01 * 100) / 100; 
                
            } else if (lineWidth == targetLineWidth){
                lineWidth = targetLineWidth;
            } else if (lineWidth > targetLineWidth) {
                //lineWidth -= 0.01;
                lineWidth = (lineWidth * 100 - 0.01 * 100) / 100; 
                lineWidth = lineWidth.toFixed(2);
            }
            //console.log(lineWidth);
            //console.log("lineWidth: "+lineWidth+" targetLineWidth: "+targetLineWidth );
            /*
            if(scroll>0.1){
                fontSize = fontSize*scroll;
            }
            */
        }
        
        var balls = [];
        
        //below: seemingly unused by orig code?
        /*
        Ball.prototype.collisionDetect = function() {
            for (j = 0; j < balls.length; j++) {
                if ((!(this.x === balls[j].x && this.y === balls[j].y && this.velX === balls[j].velX && this.velY === balls[j].velY))) {
                    var dx = this.x - balls[j].x;
                    var dy = this.y - balls[j].y;
                    var distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < this.size + balls[j].size) {
                        balls[j].color = this.color = 'rgb(' + random(0, 255) + ',' + random(0, 255) + ',' + random(0, 255) + ')';
                    }
                }
            }
        }
        */

        
        function loop() {
            ctx.clearRect(0, 0, width, height);

            while (balls.length < wordCount) {
                for (i = 0; i < wordCount; i++) {
                    var ball = new Ball(i);
                    ball.getLetters();
                    //console.log(ball);
                    balls.push(ball);
                }
                /*
                for (i=0; i < wordCount; i++) { //this somehow only fills out two words' letters, why? 
                    //balls[i].getLetters();
                    console.log(balls[i]);
                }
                */
            }

            for (i = 0; i < balls.length; i++) {
                balls[i].draw();
                balls[i].update();
                var ballLetters = balls[i].letters;
                //console.log(ballLetters);
                for (ii=0;ii<ballLetters.length;ii++) {
                    ballLetters[ii].update();
                }
            }
            
            // this is shitty, but works mostly
            window.onscroll = function() {scrollFunction()};
            function scrollFunction() {
              if (document.body.scrollTop > 80 || document.documentElement.scrollTop > 80) {
                    targetFontSize = minFontSize;
                    targetLineWidth = minLineWidth;
                      
                    for (i=0;i<wordCount;i++){
                        var currBall = balls[i];
                        var shrunkWidth= widthChange(currBall, "shrink"); 
                        //console.log("shrunk value: "+shrinktest);
                        //console.log("mintextiwdth: "+currBall.minTextWidth);
                        //around 5-7px difference between elements minWidth & widthChange return value
                        //currBall.targetTextWidth = currBall.minTextWidth;
                        currBall.targetTextWidth = Math.round(shrunkWidth);
                        //now calculate all of a words' letter widths
                        var currBallLetterLength = currBall.letters.length;
                        for(ii=0;ii<currBallLetterLength;ii++) {
                            var currLetter = currBall.letters[ii];
                            //console.log("for "+currLetter.letter+" targetWidth is "+currLetter.targetLetterWidth);
                            //console.log(currLetter.letter+" minWidth is "+currLetter.minTextWidth);
                            currLetter.targetLetterWidth = currLetter.minTextWidth;
                        }
                    }
                      
              } else if (document.body.scrollTop < 81 || document.documentElement.scrollTop < 81) {
                    targetFontSize = maxFontSize;
                    targetLineWidth = maxLineWidth;
                  
                    for (i=0;i<wordCount;i++){
                        var currBall = balls[i];
                        var growWidth= widthChange(currBall, "grow"); 
                        currBall.targetTextWidth = Math.round(growWidth);
                        //currBall.targetTextWidth = currBall.maxTextWidth;
                        //now calculate all of a words' letter widths
                        var currBallLetterLength = currBall.letters.length;
                        for(ii=0;ii<currBallLetterLength;ii++) {
                            var currLetter = currBall.letters[ii];
                            //console.log("for "+currLetter.letter+" targetWidth is "+currLetter.targetLetterWidth);
                            //console.log(currLetter.letter+" minWidth is "+currLetter.maxTextWidth);
                            currLetter.targetLetterWidth = currLetter.maxTextWidth;
                        }
                    }
              }
            }

            requestAnimationFrame(loop);
        }
        
        loop();
        
        initialize();
        
            
        function initialize() {
           // Register an event listener to call the resizeCanvas() function 
           // each time the window is resized.
           window.addEventListener('resize', resizeCanvas, false);
           // Draw canvas border for the first time.
           resizeCanvas();
        }
        
        // Runs each time the DOM window resize event fires.
        // Resets the canvas dimensions to match window,
        // then draws the new borders accordingly.
        function resizeCanvas() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            
            if (window.screen.width * window.devicePixelRatio > window.screen.height * window.devicePixelRatio) {
                //console.log("width is bigger");
                fontSize = Math.round(height / 2);
                minFontSize = Math.round(fontSize / 4);
            } else {
                //console.log("height is bigger");
                fontSize = Math.round(width / 2);
                minFontSize = Math.round(fontSize / 4);
            }
        }
             
        });
    </script>
	
</body>

</html>